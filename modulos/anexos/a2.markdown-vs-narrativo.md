# Markdown vs. Texto Narrativo para Contexto y Prompts

## Introducción

La elección del formato para comunicar contexto e instrucciones a agentes de IA y LLMs tiene un impacto directo en la calidad de las respuestas generadas. Este documento analiza por qué Markdown es preferible al texto narrativo tradicional para este propósito.

---

## 1. Estructura Natural y Jerárquica

Markdown utiliza una sintaxis ligera pero poderosa que permite organizar información de manera jerárquica y lógica.

### Encabezados como Estructura Conceptual

```markdown
# Proyecto: Portal de Empleo API

## Módulo: Autenticación

### Requisitos Funcionales
- El sistema debe permitir registro de usuarios
- El sistema debe validar emails únicos

### Requisitos No Funcionales
- Usar BCrypt para contraseñas
- JWT con expiración de 60 minutos

### Criterios de Aceptación
1. Usuario puede registrarse con email válido
2. Sistema rechaza emails duplicados
3. Contraseña debe cumplir complejidad mínima
```

Esta estructura permite al LLM identificar rápidamente:
- El alcance del proyecto
- El módulo específico
- Los requisitos aplicables
- Los criterios de verificación

### Comparación con Texto Narrativo

**Texto narrativo (problemático):**
```
El sistema de autenticación debe permitir que los usuarios se registren con un email único 
y contraseña segura. Los requisitos incluyen validar el formato del email, rechazar emails 
duplicados, y la contraseña debe tener al menos 8 caracteres con mayúsculas, minúsculas, 
números y caracteres especiales. El sistema usará JWT tokens con expiración de 60 minutos 
y BCrypt para hashear contraseñas. Los criterios de aceptación son que un usuario puede 
registrarse con email válido, el sistema debe rechazar emails duplicados, y la contraseña 
debe cumplir los requisitos de complejidad.
```

**Markdown (claro y escaneable):**
```
## Autenticación

### Requisitos
- Email único con formato válido
- Contraseña: mínimo 8 caracteres, mayúsculas, minúsculas, números, especiales
- JWT: 60 minutos de expiración
- BCrypt para hasheo

### Criterios de Aceptación
1. ✅ Registro con email válido
2. ✅ Rechazo de emails duplicados
3. ✅ Validación de complejidad de contraseña
```

---

## 2. Legibilidad para el Modelo

### Patrones de Entrenamiento

Los LLMs como GPT-4 han sido entrenados con millones de documentos que utilizan Markdown como formato estándar:
- Documentación técnica (GitHub, ReadTheDocs)
- README.md de proyectos open source
- Issues y pull requests en GitHub
- Foros como Stack Overflow

Esta exposición masiva significa que los modelos tienen una comprensión profunda de la estructura semántica de Markdown.

### Bloques de Código

Markdown permite separar claramente el código del texto descriptivo:

```markdown
## Requisito: Entidad User

Crear una entidad User con las siguientes propiedades:

```csharp
public class User
{
    public Guid Id { get; set; }
    [Required]
    [MaxLength(256)]
    public string Email { get; set; }
    
    public UserRole Role { get; set; }
    public bool IsActive { get; set; }
    public DateTime CreatedAt { get; set; }
}
```

### Enumeraciones Claras

```markdown
## UserRole Enum

| Valor | Descripción |
|-------|-------------|
| CANDIDATE | Buscador de empleo |
| COMPANY | Empresa reclutadora |
| ADMIN | Administrador del sistema |
```

---

## 3. Portabilidad entre Herramientas

### Ecosistema Compatible

| Herramienta | Soporte Markdown |
|-------------|------------------|
| VS Code | Nativo |
| GitHub | Nativo |
| GitLab | Nativo |
| Notion | Nativo |
| Obsidian | Nativo |
| Jira | Plugin disponible |
| Confluence | Nativo |

### Integración con Spec Kit y AGENTS.md

El enfoque SDD del curso se basa en archivos markdown:

```markdown
# AGENTS.md

## @backend-dev

### Contexto
Especialista en APIs REST con .NET 8.0

### Especialidades
- Clean Architecture
- Entity Framework Core
- JWT Authentication

### Formato de Respuesta
- Code blocks con lenguaje especificado
- Explicaciones breves antes del código
```

### Control de Versiones

Los archivos Markdown se versionan perfectamente en Git:
```bash
git diff specs/001-auth/spec.md
# Muestra cambios de manera legible
```

---

## 4. Separación de Concerns

### Elementos Markdown y sus Usos

| Elemento | Símbolo | Caso de Uso |
|----------|---------|-------------|
| Título nivel 1 | `#` | Nombre del documento |
| Título nivel 2 | `##` | Secciones principales |
| Título nivel 3 | `###` | Subsecciones |
| Negrita | `**texto**` | Conceptos clave |
| Cita | `> texto` | Requisitos/Constraints |
| Código inline | `` `code` `` | Nombres de variables/métodos |
| Bloque código | ```csharp``` | Ejemplos de código |
| Tabla | `| col | col |` | Datos estructurados |
| Lista | `- item` | Enumeraciones |
| Checklist | `- [ ] item` | Criterios de aceptación |
| Enlace | `[texto](url)` | Referencias |

### Ejemplo de Uso Combinado

```markdown
# Spec: Módulo de Autenticación

> **Constraint:** Usar BCrypt con work factor 12

## Requisitos Funcionales

### RF-001: Registro de Usuario

| Campo | Tipo | Validación |
|-------|------|------------|
| Email | string | Required, Email, Unique |
| Password | string | MinLength(8), Complex |
| Name | string | Required, MaxLength(100) |

### Criterios de Aceptación

- [ ] Usuario puede registrarse con email válido
- [ ] Sistema rechaza emails duplicados
- [ ] Contraseña cumple requisitos de complejidad

## Implementación de Referencia

```csharp
public class User
{
    public Guid Id { get; set; }
    public string Email { get; set; }
    public string PasswordHash { get; set; }
    public UserRole Role { get; set; } = UserRole.CANDIDATE;
}
```

## Notas
- Verificar mayoría de edad (16 años) en BirthDate
- Role por defecto: CANDIDATE
- Email no modificable tras registro
```

---

## 5. Ejemplo Comparativo: Prompt de Entity Framework

### ❌ Texto Narrativo (Problemático)

```
Create a User entity for a job portal API. It should have Id as Guid, Email as string that is unique and required, Password as string that will be hashed, Name as string max 100 characters, BirthDate as DateTime, Phone as string optional, Skills as List of strings, Role as enum with CANDIDATE COMPANY ADMIN values, IsActive as bool for soft delete, CreatedAt and UpdatedAt as DateTime. Include data annotations for validation. The entity should follow Clean Architecture principles and be in the Domain layer. Use XML documentation for all public members. Also create a UserRole enum with the values mentioned.
```

### ✅ Markdown Estructurado (Preferible)

```markdown
## Task: Crear User Entity

### Contexto
- Proyecto: Portal de Empleo API
- Arquitectura: Clean Architecture
- Capa: Domain Layer

### Propiedades de la Entidad

| Propiedad | Tipo | Atributos | Descripción |
|-----------|------|-----------|-------------|
| Id | Guid | [Key] | Primary key, autogenerado |
| Email | string | [Required], [MaxLength(256)], [EmailAddress] | Único |
| Password | string | [Required] | Será hasheado con BCrypt |
| Name | string | [Required], [MaxLength(100)] | Nombre completo |
| BirthDate | DateTime | - | Validar mayoría de edad |
| Phone | string | [MaxLength(20)], opcional | Formato internacional |
| Skills | List<string> | - | Habilidades del candidato |
| Role | UserRole | default: CANDIDATE | Rol del usuario |
| IsActive | bool | default: true | Soft delete |
| CreatedAt | DateTime | - | Fecha de creación |
| UpdatedAt | DateTime | - | Última modificación |

### Enumeración UserRole

```csharp
public enum UserRole
{
    CANDIDATE = 0,
    COMPANY = 1,
    ADMIN = 2
}
```

### Requisitos Adicionales

- [ ] Incluir XML Documentation para todos los miembros públicos
- [ ] Seguir convenciones de nomenclatura C#
- [ ] Usar inicialización de propiedades
- [ ] Ubicación: `PortalEmpleo.Domain/Entities/`

### Salida Esperada

```csharp
namespace PortalEmpleo.Domain.Entities
{
    /// <summary>
    /// Represents a user in the job portal system.
    /// </summary>
    public class User
    {
        // Código aquí
    }
}
```

### Explicación de la Diferencia

| Aspecto | Narrativo | Markdown |
|---------|-----------|----------|
| Escaneable | No | Sí |
| Parsing por LLM | Propenso a errores | Preciso |
| Completitud | Puede omitir detalles | Estructura garantiza cobertura |
| Mantenimiento | Difícil actualizar | Fácil de modificar |
| Reutilización | Limitada | Alta (secciones copiables) |

---

## 6. Casos de Uso en el Curso

### Caso 1: AGENTS.md

```markdown
# AGENTS.md - Portal de Empleo API

## @backend-dev

### Contexto
Desarrollador backend especializado en .NET 8.0 y APIs RESTful.

### Especialidades
- Clean Architecture
- Entity Framework Core 8.0
- JWT Authentication con Refresh Tokens
- FluentValidation
- xUnit Testing

### Constraints
- Usar patrones Repository y Unit of Work
- Siempre incluir XML Documentation
- Seguir principios SOLID
- Code style: puntos y coma, PascalCase

### Formato de Respuesta
1. Breve explicación del enfoque
2. Código en bloques con lenguaje especificado
3. Notas sobre consideraciones adicionales
```

### Caso 2: Spec.md

```markdown
# Spec: Autenticación

## Historias de Usuario

### HU-001: Registro de Usuario

**Como** candidato\
**Quiero** registrarme con email y contraseña\
**Para** acceder a las funcionalidades del portal

#### Criterios de Aceptación
- [ ] Email con formato válido
- [ ] Email único en el sistema
- [ ] Contraseña: mínimo 8 caracteres
- [ ] Contraseña: mayúsculas, minúsculas, números, especiales
- [ ] Rol por defecto: CANDIDATE
- [ ] Devolver JWT tokens

#### Notas
- No permitir auto-registro de empresas
- Validar mayoría de edad (16 años)
```

### Caso 3: Prompt de Implementación

```markdown
## Prompt: Implementar IUserRepository

### Contexto
- Interface para el repositorio de usuarios
- Patrón Repository con operaciones asíncronas

### Métodos Requeridos

| Método | Parámetros | Retorno | Descripción |
|--------|------------|---------|-------------|
| AddAsync | User user | Task | Agregar usuario |
| GetByIdAsync | Guid id | Task<User?> | Buscar por ID |
| GetByEmailAsync | string email | Task<User?> | Buscar por email |
| UpdateAsync | User user | Task | Actualizar usuario |
| DeleteAsync | Guid id | Task | Soft delete |

### Requisitos
- Usar CancellationToken
- Documentación XML
- Seguir convenciones del proyecto

### Excepciones a Documentar
- UserNotFoundException
- DuplicateEmailException
```

---

## 7. Conclusiones

### ¿Por qué Markdown es Superior?

| Factor | Markdown | Narrativo |
|--------|----------|-----------|
| **Estructura** | Jerarquía clara | Plana, difícil de navegar |
| **Precisión** | Datos estructurados en tablas | Ambiguo, propenso a interpretación |
| **Mantenibilidad** | Secciones modulares | Todo junto, difícil de actualizar |
| **Reutilización** | Bloques copiables | Todo o nada |
| **Integración** | Git, IDEs, herramientas | Limitada |
| **Calidad del Output** | Prompts detallados = mejor código | Prompts vagos = código inconsistente |

### Regla de Oro

> **"Si no puedes estructurarlo en Markdown, no está lo suficientemente claro para un LLM."**

### Formula del Éxito

```
Prompt Estructurado en Markdown
        +
Contexto Relevant
        +
Requisitos Específicos
        =
Código de Calidad con Mínima Revisión
```

---

## 8. Recursos Adicionales

### Herramientas para Editar Markdown

| Herramienta | Plataforma | Características |
|-------------|------------|-----------------|
| VS Code | Multiplataforma | Live Preview, extensiones |
| Typora | Windows/Mac | WYSIWYG y código |
| Obsidian | Multiplataforma | Grafo de conocimiento |
| HackMD | Web | Colaboración en tiempo real |

### Extensiones VS Code Recomendadas

- **Markdown All in One**: Atajos y previsualización
- **Markdownlint**: Linting para Markdown
- **Paste Image**: Pegar imágenes desde portapapeles
- **Markdown Preview Mermaid Support**: Diagramas Mermaid

---

## 9. Ejercicio Práctico

### Transformar de Narrativo a Markdown

**Texto original (narrativo):**
```
El sistema de ofertas de empleo debe permitir a las empresas crear nuevas ofertas. Cada oferta tiene un título máximo 200 caracteres, descripción detallada, años de experiencia requeridos, salario opcional con moneda, ubicación, si es remoto o no, tipo de contrato que puede ser tiempo completo medio tiempo temporal o freelance, fecha límite de postulación, y estado que puede ser borrador publicada pausada o cerrada. Las ofertas en estado borrador no son visibles para candidatos. Solo las ofertas publicadas reciben postulaciones.
```

**Transformar a Markdown:**

<details>
<summary>Ver solución</summary>

```markdown
## Entidad: JobOffer

### Propiedades

| Propiedad | Tipo | Requisito | Descripción |
|-----------|------|-----------|-------------|
| Id | Guid | Requerido | Identificador único |
| Title | string | Max 200 | Título del puesto |
| Description | string | Requerido | Descripción detallada |
| ExperienceYears | int | Requerido | Años de experiencia |
| Salary | decimal? | Opcional | Salario ofrecido |
| SalaryCurrency | string | Opcional | Moneda del salario |
| Location | string? | Opcional | Ubicación física |
| IsRemote | bool | Default: false | Remoto/Híbrido/Presencial |
| ContractType | ContractType | Requerido | Tipo de contrato |
| ApplicationDeadline | DateTime? | Opcional | Fecha límite |
| Status | JobOfferStatus | Default: DRAFT | Estado de la oferta |
| CompanyId | Guid | Requerido | ID de la empresa |
| CreatedAt | DateTime | Auto | Fecha de creación |
| UpdatedAt | DateTime | Auto | Última modificación |

### Enumeraciones

```csharp
public enum ContractType
{
    FULL_TIME = 0,
    PART_TIME = 1,
    TEMPORARY = 2,
    FREELANCE = 3
}

public enum JobOfferStatus
{
    DRAFT = 0,      // No visible para candidatos
    PUBLISHED = 1,  // Visible y recibiendo postulaciones
    PAUSED = 2,     // Temporalmente oculta
    CLOSED = 3      // Finalizada, sin postulaciones
}
```

### Reglas de Negocio

- [ ] Solo ofertas en estado PUBLISHED son visibles
- [ ] Solo ofertas PUBLISHED aceptan postulaciones
- [ ] Transición DRAFT → PUBLISHED es irreversible
- [ ] Para modificar oferta PUBLISHED, primero PAUSAR
</details>

---

## Resumen

Markdown es el formato ideal para comunicar contexto e instrucciones a LLMs porque:

1. **Estructura jerárquica** que el modelo puede interpretar
2. **Legibilidad** tanto para humanos como para máquinas
3. **Portabilidad** entre todas las herramientas de desarrollo
4. **Separación clara** de concerns mediante elementos específicos
5. **Calidad superior** del código generado

En el contexto del curso de Copilot, dominar Markdown es fundamental para:
- Crear AGENTS.md efectivos
- Escribir specs claras
- Diseñar prompts precisos
- Documentar decisiones arquitectónicas
