# Custom Agents en VS Code - Guía Completa

## 1. Definición

### ¿Qué es un Custom Agent?

Un **Custom Agent** (agente personalizado) en VS Code es una configuración de IA especializada que permite adoptar diferentes personalidades y conjuntos de herramientas adaptadas a roles de desarrollo específicos. A diferencia del comportamiento general de Copilot, los custom agents definen exactamente cómo debe comportarse el asistente de IA, qué herramientas tiene disponibles y qué instrucciones específicas debe seguir para completar la tarea concretas.

Los custom agents se crean mediante archivos Markdown con extensión `.agent.md` que contienen metadatos YAML y un cuerpo con instrucciones. Estos archivos pueden almacenarse en el workspace para uso del equipo o en el perfil de usuario para reutilización entre diferentes proyectos. La principal ventaja radica en la capacidad de configurar agentes especializados como revisores de seguridad, planificadores de implementación, arquitectos de software o auditores de código, cada uno con su propio conjunto de herramientas y directrices específicas.

### Diferencia con MCP y Prompt Files

Es importante distinguir entre custom agents, MCP servers y prompt files ya que cada uno cumple una función diferente en el ecosistema de Copilot. Los **custom agents** definen personalidades y comportamientos completos del asistente, incluyendo instrucciones, herramientas disponibles y transiciones entre agentes. Los **MCP servers** (Model Context Protocol) proporcionan herramientas y recursos externos que el agente puede utilizar, como conexiones a bases de datos, APIs o sistemas externos. Los **prompt files** son plantillas de prompts reutilizables que se aplican a interacciones específicas del chat, sin definir un comportamiento persistente del agente.

### Casos de Uso Comunes

Los custom agents son especialmente útiles en escenarios donde se requiere un comportamiento consistente y especializado. Un agente de **planificación** puede configurarse para solo utilizar herramientas de solo lectura como búsqueda, lectura de archivos y análisis de código, evitando modificaciones accidentales mientras genera planes de implementación detallados. Un agente de **revisión de seguridad** puede enfocarse en identificar vulnerabilidades específicas siguiendo checklists de OWASP Top 10. Un agente de **revisión de código** puede evaluar la calidad del código según estándares del equipo, verificando nomenclatura, manejo de errores y patrones de diseño.

## 2. Cabecera

### Estructura del YAML Frontmatter

La cabecera de un custom agent utiliza formato YAML (YAML frontmatter) al inicio del archivo `.agent.md`. Esta sección define las propiedades de configuración del agente que determinan su comportamiento, herramientas disponibles y transiciones. La sintaxis sigue el patrón de tres guiones `---` para abrir y cerrar el bloque YAML.

```yaml
---
description: "Genera un plan de implementación detallado para nuevas características."
name: "Planner"
argument-hint: "Describe la característica o refactorización que necesitas planificar"
tools: ['fetch', 'githubRepo', 'search', 'usages']
model: "Claude Sonnet 4"
infer: true
target: "vscode"
handoffs:
  - label: "Implementar Plan"
    agent: "agent"
    prompt: "Implementa el plan descrito anteriormente."
    send: false
---
```

### Propiedades de Configuración

La propiedad **description** proporciona una breve descripción del agente que se muestra como texto placeholder en el campo de entrada del chat. Esta descripción debe ser concisa pero informativa, indicando claramente el propósito del agente para que los usuarios puedan seleccionarlo apropiadamente. Se recomienda mantener esta descripción bajo 100 caracteres para una experiencia de usuario óptima.

La propiedad **name** define el nombre del agente que aparece en el dropdown de agentes del panel de chat. Si no se especifica, se utiliza el nombre del archivo como valor predeterminado. El nombre debe ser descriptivo y fácil de identificar entre múltiples agentes personalizados.

La propiedad **argument-hint** es opcional y proporciona texto guía que aparece en el campo de entrada para orientar al usuario sobre cómo interactuar con el agente. Esta propiedad es especialmente útil cuando el agente espera parámetros específicos o sigue un formato de interacción particular.

La propiedad **tools** especifica una lista de herramientas o conjuntos de herramientas disponibles para este agente. Las herramientas pueden incluir herramientas integradas de VS Code, conjuntos de herramientas predefinidos, herramientas MCP o herramientas contribuidas por extensiones. Para incluir todas las herramientas de un servidor MCP específico, se utiliza el formato `<nombre-servidor>/*`. La selección de herramientas es fundamental para controlar el alcance de las acciones que el agente puede realizar.

### Selección de Modelo y Configuración Avanzada

La propiedad **model** especifica el modelo de IA a utilizar cuando se ejecuta el prompt del agente. Si no se especifica, se utiliza el modelo actualmente seleccionado en el selector de modelos del chat. Esta propiedad permite optimizar el rendimiento del agente seleccionando modelos más adecuados para tareas específicas, ya sea modelos más rápidos para tareas simples o modelos más capaces para tareas complejas.

La propiedad **infer** es un flag booleano opcional que habilita el uso del agente como subagente en sesiones de chat aisladas. El valor predeterminado es `true`, permitiendo que el agente sea utilizado recursivamente dentro de otras conversaciones. Desactivar esta propiedad puede ser útil para agentes que deben ejecutarse solo en el contexto principal del chat.

La propiedad **target** define el entorno objetivo o contexto para el custom agent. Los valores posibles son `vscode` para el agente local de VS Code o `github-copilot` para agentes en GitHub Copilot. Esta configuración determina qué herramientas y capacidades están disponibles para el agente según el contexto de ejecución.

## 3. Argumentos Dinámicos ($ARGUMENTS)

### Sintaxis y Uso

La sintaxis `$ARGUMENTS` permite pasar parámetros dinámicos a los custom agents cuando se invocan, haciendo que los agentes sean reutilizables para diferentes tareas sin necesidad de crear archivos separados. Cuando un usuario invoca un agente con argumentos adicionales, estos se sustituyen en las instrucciones del agente wherever se encuentre la expresión `$ARGUMENTS`.

```yaml
---
description: "Revisa un archivo o módulo específico buscando problemas de calidad y seguridad."
name: "Code Reviewer"
argument-hint: "Indica la ruta del archivo o módulo a revisar (ej: src/auth/)"
tools: ['read', 'search', 'usages']
---
# Code Reviewer Agent

Revisa el siguiente código según los estándares de calidad del proyecto:

$ARGUMENTS

## Checklist de Revisión

1. **Legibilidad y Nomenclatura**
   - Los nombres de funciones y variables son descriptivos
   - El código sigue los patrones de naming del proyecto

2. **Manejo de Errores**
   - Todas las funciones tienen manejo de errores apropiado
   - Los errores proporcionan información útil para debugging

3. **Seguridad**
   - No hay credenciales o secrets expuestos
   - Las entradas de usuario están validadas
   - Las consultas a base de datos usan consultas parametrizadas

4. **Rendimiento**
   - No hay bucles infinitos o operaciones bloqueantes
   - Las operaciones costosas son asíncronas cuando corresponde

Proporciona el feedback organizado por prioridad: Crítico → Advertencias → Sugerencias.
```

### Variables de Contexto Disponibles

Además de `$ARGUMENTS`, los custom agents pueden acceder a otras variables de contexto que proporcionan información sobre el entorno y la sesión actual. La variable `${cursor}` representa la posición actual del cursor en el editor, `${file}` indica el archivo activo, y `${workspaceFolder}` especifica la carpeta del workspace actual. Estas variables permiten crear agentes que actúan sobre el contexto específico del desarrollador.

### Ejemplos de Uso con $ARGUMENTS

Para crear un agente de análisis de código que acepte diferentes tipos de análisis, se puede configurar el agent con $ARGUMENTS para dynamically cambiar el enfoque:

```yaml
---
description: "Analiza código según el tipo especificado."
name: "Code Analyzer"
argument-hint: "Tipo de análisis: performance | security | quality | all"
tools: ['read', 'search', 'fetch']
---
# Code Analyzer

Realiza un análisis de tipo "$ARGUMENTS" del código seleccionado o modificado:

$ARGUMENTS

## Parámetros de Análisis

| Tipo | Enfoque |
|------|---------|
| performance | Identifica cuellos de botella, optimiza queries,缓存 |
| security | Busca vulnerabilidades, injection points, auth issues |
| quality | Evalúa test coverage, deuda técnica, complejidad |
| all | Combina todos los análisis anteriores |

Comienza identificando los archivos modificados y aplica el análisis correspondiente.
```

### Comportamiento con Argumentos Vacíos

Cuando un agente es invocado sin argumentos adicionales, la expresión `$ARGUMENTS` se elimina completamente del prompt, dejando solo las instrucciones base del agente. Esto permite diseñar agentes con comportamiento predeterminado cuando no se proporcionan parámetros, manteniendo flexibilidad para personalizaciones específicas.

## 4. Cuerpo

### Estructura del System Prompt

El cuerpo del archivo `.agent.md` contiene las instrucciones específicas que definen el comportamiento del agente, formateadas como contenido Markdown. Estas instrucciones se prep部enden al prompt del usuario cuando se selecciona el agente en el chat, estableciendo el contexto y las directrices para todas las interacciones subsecuentes. El contenido del cuerpo debe ser claro, específico y estructurado para guiar el comportamiento del agente de manera consistente.

```markdown
---
description: "Analiza el código para identificar deuda técnica y oportunidades de refactorización."
name: "Technical Debt Analyzer"
tools: ['read', 'search', 'usages', 'fetch']
---
# Technical Debt Analyzer

Eres un arquitecto de software senior especializado en identificar deuda técnica y proponer soluciones de refactorización.

## Tu Misión

Analizar el código base para identificar:
1. Código duplicado que puede ser extraído a funciones o clases reutilizables
2. Funciones demasiado largas que deben ser descompuestas
3. Acoplamiento excesivo entre módulos
4. Falta de abstracción donde corresponde
5. Tests faltantes o insuficientes

## Enfoque de Análisis

Para cada archivo o módulo analizado:

1. **Inventario de Problemas**
   - Identifica los issues más críticos primero
   - Estima el esfuerzo de corrección
   - Prioriza por impacto en mantenibilidad

2. **Propuestas de Refactorización**
   - Describe el problema identificado
   - Proporciona la solución propuesta
   - Incluye ejemplo de código refactorizado
   - Estima el riesgo de la refactorización

3. **Recomendaciones**
   - Acciones inmediatas (1-2 días)
   - Mejoras a mediano plazo (1-2 semanas)
   - Transformaciones arquitectónicas a largo plazo

## Restricciones

- No modifiques el código directamente
- Proporciona solo análisis y recomendaciones
- Si no estás seguro de algo, indícalo claramente
- Enfócate en problemas con alto impacto en mantenibilidad
```

### Mejores Prácticas para Instrucciones

Las instrucciones del cuerpo deben ser específicas y accionables, evitando ambigüedades que puedan llevar a comportamientos inconsistentes. Se recomienda usar listas numeradas o con viñetas para pasos claramente secuenciables, y tablas para organizar criterios de evaluación o categorías de problemas. La inclusión de ejemplos concretos ayuda al agente a entender el formato y nivel de detalle esperado en sus respuestas.

Es importante definir claramente los límites del agente, especificando qué no debe hacer además de qué sí debe hacer. Las restricciones explícitas ayudan a prevenir comportamientos no deseados y garantizan que el agente se mantenga dentro del alcance previsto. Por ejemplo, un agente de revisión de código no debe realizar modificaciones directas al código, solo identificar problemas y sugerir mejoras.

### Referencia a Herramientas en el Cuerpo

Para hacer referencia a herramientas específicas dentro del texto del cuerpo, se utiliza la sintaxis `#tool:<nombre-herramienta>`. Por ejemplo, `#tool:githubRepo` referencia la herramienta de repositorios de GitHub. Esta sintaxis permite incluir documentación sobre herramientas directamente en las instrucciones del agente, ayudando a guiar su uso apropiado.

```markdown
## Uso de Herramientas

- Usa `#tool:read` para examinar el contenido de archivos específicos
- Usa `#tool:search` para encontrar patrones en el código
- Usa `#tool:githubRepo` para obtener información del repositorio
- Usa `#tool:usages` para identificar dónde se usa una función o clase

No uses herramientas de escritura (edit, write) a menos que el usuario lo solicite explícitamente.
```

### Reutilización de Instrucciones

Los custom agents pueden hacer referencia a otros archivos mediante enlaces Markdown, permitiendo reutilizar instrucciones comunes o constitution files del proyecto. Esta característica es especialmente útil cuando múltiples agentes comparten directrices comunes como estándares de código, políticas de seguridad o convenciones del equipo.

```markdown
## Estándares Aplicables

Consulta los estándares del proyecto en:
- [Constitution del Proyecto](../.specify/memory/constitution.md)
- [Guía de Estilos](../docs/style-guide.md)

Las instrucciones de estos archivos se aplican a menos que contradigan específicamente las instrucciones de este agente.
```

## 5. Ejemplo Completo

### Agent: Security Reviewer

El siguiente ejemplo muestra un custom agent completo para revisión de seguridad de código, incluyendo todas las secciones y propiedades descritas anteriormente.

````yaml
---
description: "Identifica vulnerabilidades de seguridad y propone correcciones."
name: "Security Reviewer"
argument-hint: "Indica el módulo o archivo a auditar (ej: src/auth/)"
tools: ['read', 'search', 'usages', 'fetch']
model: "Claude Sonnet 4"
handoffs:
  - label: "Corregir Vulnerabilidades"
    agent: "implementation"
    prompt: "Implementa las correcciones de seguridad descritas en el análisis anterior."
    send: false
---
# Security Reviewer Agent

Eres un experto en seguridad de aplicaciones con experiencia en OWASP Top 10 y mejores prácticas de desarrollo seguro.

## Alcance de la Revisión

Analiza el código en busca de las siguientes categorías de vulnerabilidades:

### OWASP Top 10

| Categoría | Descripción | Buscar |
|-----------|-------------|--------|
| A01:2021 - Broken Access Control | Controles de acceso bypassed | IDs incrementales, falta de autorización |
| A02:2021 - Cryptographic Failures | Datos sensibles expuestos | Hardcoded secrets, SSL no forzado |
| A03:2021 - Injection | Inyección de código | SQL injection, XSS, Command injection |
| A04:2021 - Insecure Design | Diseño inseguro | Falta de rate limiting, validación débil |
| A05:2021 - Security Misconfiguration | Configuración insegura | CORS, headers faltantes, debug habilitado |

### Patrones Específicos a Buscar

1. **SQL Injection**
   - Consultas concatenadas con strings
   - Interpolación de variables en queries
   - Falta de consultas parametrizadas

2. **Cross-Site Scripting (XSS)**
   - output sin sanitización
   - innerHTML con contenido dinámico
   - Eval con entrada de usuario

3. **Authentication Issues**
   - Contraseñas hardcodeadas
   - Tokens en URLs
   - Sesiones que no expiran

4. **Sensitive Data Exposure**
   - Logs de datos sensibles
   - Errores que muestran stack traces
   - Cifrado débil o ausente

## Formato del Reporte

Para cada vulnerabilidad encontrada:

```
## [Severidad] Nombre de la Vulnerabilidad

**Archivo:** `ruta/archivo.js:45`

**Descripción:**
Breve descripción del problema...

**Código Vulnerable:**
\`\`\`javascript
// Código problemático aquí
\`\`\`

**Riesgo:** Alto/Medio/Bajo
**Explotabilidad:** Fácil/Moderada/Difícil

**Corrección Propuesta:**
\`\`\`javascript
// Código corregido aquí
\`\`\`

**Referencias:**
- OWASP: [enlace]
- CWE: [enlace]
```

## Notas para el Analista

- Prioriza vulnerabilidades que pueden ser explotadas remotamente
- Si no tienes certeza sobre el contexto, indícalo
- Enfócate en hallazgos accionables con correcciones claras
- No reportes falsos positivos de sanitizadores de entrada existentes
```

### Instalación del Agent

Para crear este agente en VS Code, sigue estos pasos:

```bash
# 1. Crear el directorio de agents si no existe
mkdir -p .github/agents

# 2. Crear el archivo del agente
touch .github/agents/security-reviewer.agent.md

# 3. Copiar el contenido YAML y Markdown al archivo

# 4. Recargar VS Code o activar el Command Palette
#    Chat: New Custom Agent > Seleccionar el archivo creado
````

### Uso del Agent

Una vez instalado, el agente aparece en el dropdown de agentes del panel de chat de VS Code. Para usarlo:

1. Seleccionar **"Security Reviewer"** del dropdown de agentes
2. Especificar el módulo a auditar: `src/auth/` o `src/api/`
3. El agente analizará el código y generará un reporte de vulnerabilidades
4. Usar los botones de handoff para continuar con la implementación de correcciones o generación de tests

## 6. Referencias

### Documentación Oficial

- **VS Code Custom Agents Documentation**: https://code.visualstudio.com/docs/copilot/customization/custom-agents
- **GitHub Copilot Custom Agents**: https://docs.github.com/en/copilot/how-tos/use-copilot-agents/coding-agent/create-custom-agents
- **Chat Tools Reference**: https://code.visualstudio.com/docs/copilot/chat/chat-tools
- **MCP Servers Documentation**: https://code.visualstudio.com/docs/copilot/customization/mcp-servers

### Recursos Adicionales

- **Awesome Copilot Repository**: https://github.com/github/awesome-copilot/tree/main (ejemplos de custom agents contribuidos por la comunidad)
- **Spec Kit Documentation**: https://github.com/github/spec-kit (flujo de trabajo SDD con custom agents)
- **Prompt Engineering Guide**: https://code.visualstudio.com/docs/copilot/guides/prompt-engineering-guide

### Artículos de Referencia

- **Claude Code Custom Commands**: https://claudefa.st/blog/guide/agents/custom-agents (patrones de diseño para agentes personalizados)
- **Agent Skills Documentation**: https://code.visualstudio.com/docs/copilot/customization/agent-skills

### Véase También

- `base/0.objetivos_curso.md` - Objetivos y herramientas del curso
- `base/spec-kit.md` - GitHub Spec Kit para desarrollo dirigido por especificaciones
- `modules/anexos/a2.mcp-servers.md` - Model Context Protocol servers
- `modules/anexos/a3.prompt-files.md` - Prompt files reutilizables
